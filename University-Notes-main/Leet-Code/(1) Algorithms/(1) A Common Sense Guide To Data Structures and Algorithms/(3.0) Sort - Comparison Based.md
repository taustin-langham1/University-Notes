# Speeding up your code with Big O
## Speeding
##### bubble sort

[0                N]

zero to n
go up to, but not N

so i up to N - 1

so i, and i + 1

	for i .... n
	
		for j.. n - 1 - 1 <- as last item has become sorted, in sorting an array
		
		if(arr[i] > arr[j])
		swap(i, j)


in code: 

```
public static void bubbleSort(Int[] Array){
		
		for (int i; i < Array.length; ++i){
		
				for(int j; j < Array.length - 1 - i; ++j){
				
					// doing something in the J th loop
						// for the J that is being assessed, look at J + 1
						if(arr[j] > arr[j + 1]){
						
							int temp = arr[j]
							arr[j] = arr[j + 1]
							arr[j + 1] = temp    
							
							// the swapping logic isnt literally picking them up 
							// and dragging them! its making it so
							// temp (value in position to swap) overwrites the one 
							// in front of it, and the one in front of it becomes  
							// the one behind it, which sorts the list!     
							// overwriting the correct values in the desired 
							// location 
								
						}
				}
		}	
}
```

O(N^2)

#### linear duplicate solution

```

	public static Boolean hasDuplicateValue(array){
		array existingNumbers[] = null;
		
		for(int i = 0; i < array.length; i++){
				if(existingNumbers[array[i]] == 1){
				return true;
				}else{
				existingNumbers[array[i]] = 1;
				}
		}
		return false;
	} 

```

4. The following function finds the greatest single number within an array,
but has an efficiency of O(N2). Rewrite the function so that it becomes a
speedy O(N):
```
def greatestNumber(array):
for i in array:
	isIValTheGreatest = True
	for j in array:
		if j > i:
		isIValTheGreatest = False
	if isIValTheGreatest:
return i
```

```
# Assume for now that i is the greatest:

# If we find another value that is greater than i,
# i is not the greatest:

# If, by the time we checked all the other numbers, i
# is still the greatest, it means that i is the greatest number:
```

The Answer:

```
def greatestNumber(array):
greatestNumberSoFar = array[0]

for i in array:
	if i > greatestNumberSoFar
		greatestNumberSoFar = i
		
	return greatestNumberSoFar
	
```

we can use the information we find in the first look through, no need to compare an i with a j



## selection sort

```
public static int[] selectionSort(int[] inputArray){

for (int i = 0; i < inputArray.length - 1; i++){
		int lowestValueIndex = i;
		
	for(int j = 0; j < inputArray.length; j++){	
	
		if (inputArray[j] < lowestValueIndex){

		lowestValueIndex = j; 	
	}	
	
	// beautifully clear example of an i, j comparison, j looks at i
}
if (lowestValueIndex != i){
	int temp = array[i];
	array[i] = array[lowestValueIndex];
	array[lowestValueIndex] = temp; 
	
	// standard swap, seen before
}
return inputArray;
}
```

## Insertion sort

```
public static int[] insertionSort(int[] Array){
		
	for (int i = 1; i < Array.length; i++){
		int key = arr[i];
		// the value to compare
		int j = i - 1;
		// the position
		
		// if i = 4 for example, j would be 3 
		
		while(j >= 0 && Array[j] > key){
		// so if the key is less than the position
			
			Array[j+1] = Array[j];
			
			// the position to the right becomes 
			// the new position (j+1 could just be array[i]) 
			
			j--;
			
		}
	
	Array[j+1] = key
	
	// and the position to the right 
	}			
	return arr;
}

```


### Heap Sort

##### Notes:



