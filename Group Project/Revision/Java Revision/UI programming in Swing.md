
###### Lecture Layout:
- Event Dispatch thread and Swing threading 
- Event Handlers & custom events
- Nested Layouts
- Custom component types
- Swing size methods
- Graphics2D
- Accessibility in Swing 
- Making something to demonstrate iteration speed...

****
## Event Dispatch thread:

**Swing utilities class**

- swing utilities provides a collection of static methods to perform common tasks - like threading issues.

- All Swing objects should be accessed only on the **event dispatch threat (EDT)**

- this is set up automatically by swing when you create the first swing component.

- You can use these two methods to queue work on the EDT:
	``` java
	SwingUtilities.invokeLater(...)
	```

``` Java
	SwingUtilities.invokeAndWait(...)
```

- Swing event handlers also run on the event dispatch thread.
- Avoid long-running tasks on the EDT as this will block other activity!
	- consider using a separate thread either manually or via `SwingWorker` class

****
## Events in swing:

- `addActionListener(...)` is the "generic" event handler in swing but lots of components have more specific event handler(s) available
- You can find introductions to most of them in these tutorials:
- docs.oracle.com/javase/tutorial/uiswing/events/intro.html

- many action listeners depending on component. go to API for reference  

> focus listeners 
****
## Custom Events (I)

**custom events to deal with higher level components**

event listener - notifies other stakeholders of the event in the program
helps loose coupling - not dependent on high level sub component 

- create `FooListener` interface that has the methods you want to be able to trigger (ie, the events that others are interested in) 

(list inside custom component - keeps track of those interested in the events)
- Add `addFooListener(FooLitener X)`
	`/removeFooListener(FooListener X)` methods that add/remove x from a list in your component

>"say you have 15 things interested (and implement) the Listener. 15 different places in the code adding fooListener, and 15 different things in the list" "When that event happens, go through the list and call that object . name of the event you want to trigger, through the list, each time causes control to go back to the listener"

- when you want to trigger an event, iterate through your list and for each listener x, invoke the method representing that event, eg x.bar();
	- you can pass relevant extra info as parameters, eg x.bar(mouseX, curColor);
	- Or if there are lost of values, you cna make a new class to wrap all the values in an object, eg class FooEvent{...}. (This is all MouseEvent, ect are nothing magical)

## Custom Events (II)

- custom events are the way to decouple the implementation of your new components from how you want them to be used in the rest of your program
- it is essentially part of your public API.
- eg, your colour palette component make available a ColourChangeEvent that other parts of the program can subscribe to, instead of having a maze of ActionListeners and switch-ing

****
## Nesting Layout Managers:

- straight-forward layout managers: FlowLayout, GridLayout, BorderLayout, CardLayout

- more complex layout managers: GridBagLayout, SpringLayout
- You can also have no layout manager and manually position the components inside the container - *this is almost always a bad idea

- you create most reasonably complex layouts using BorderLayout and GridLayout/FlowLayout combinations. 

****
## Custom Components:

- typically either a composite of existing widgets or a completely new one.
- Composite:
	- Extend JPanel
	- Sub-components are instance variables of this object; build the UI in the constructor or an `init()` method
- New type of component:
	- Extend JComponent
		- Override `paint(...)` method 
- For both then:
	- Add swing event handlers to this and do what your component should do 
	- Provide event listener(s) for outside code to subscribe to for event(s) generated by your component

****
## Component sizes

- when using existing components, you rarely need to deal with sizes directly - the layout manager for the container takes care of that.
- For custom components, you may want to set/override:
	- `getMinimumSize()` - the smallest usable size
	- `getMaximumSize()` - the maximum usable size
	- `getPreferredSize()` - the "Ideal" size for the component
- All these can by dynamic (ie, change with the state of the component)
- Not all layout managers will respect these! (eg, `GridLayout`)
	- This is especially true if you have only a JFrame with a JPanel in it and your new component to test (eg,` BoarderLayout.CENTER` will give all the full size of the JFrame), so test with the intended UI.

****
## Custom component painting 

- the `paintX(...)` methods that you override to draw into your component all have `Graphics` object as parameter
- in Java 1.2, a new `Graphics2D` class was introduced that provides more sophisticated graphics operations including sub-pixel rendering, anti-aliasing and pixel transformations
- in order to make this available to all applications, those paint methods are always given a `Graphics2D` object (instead of `Graphics`) and you can cast it to gain access to the new methods
	- `Graphics2D g = (Graphics2D)myGraphicsParamName;`

****
## Accessibility

- any good program is accessible 

- Tooltips
	- setToolTipText("Rectangle Tool");
	- Note the capitalisation!
- Keyboard navigation
	- individual key shortcuts:
	- misc/keybinding.html

- specific swing tutorial stream for more complex issues -
docs.oracle.com/javase/tutorial/uiswing/misc/access.html

beware! toolkit features won't help a bad UI design. 
****
TODO:
- watch the "making something..." section
- read over book.
- Further clarification on the following:
	- **custom events**
	- **custom components // component sizes // component painting

